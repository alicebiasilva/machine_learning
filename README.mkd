# üìò Machine Learning

Este reposit√≥rio tem como objetivo centralizar **anota√ß√µes de aula, resumos conceituais e exemplos pr√°ticos** relacionados √† √°rea de **Machine Learning**. 

* Autora: Alice Beatriz da Silva

* √öltima atualiza√ß√£o: 20/02/2026

---


## üìö Sum√°rio


### 1. Pr√©-requisitos: Processamento de Dados e M√©tricas de Avalia√ß√£o
Antes de aprender os algoritmos de Machine Learning, √© fundamental dominar etapas de explora√ß√£o e prepara√ß√£o de dados, bem como as m√©tricas de avalia√ß√£o. 

### 2. Aprendizado Supervisionado
Estudo de algoritmos que aprendem a partir de dados rotulados, incluindo problemas de **classifica√ß√£o** e **regress√£o**, m√©tricas de avalia√ß√£o e boas pr√°ticas de modelagem.

### 3. Aprendizado N√£o Supervisionado
Explora√ß√£o de t√©cnicas utilizadas quando n√£o h√° r√≥tulos nos dados, como **clusteriza√ß√£o**, **redu√ß√£o de dimensionalidade** e an√°lise explorat√≥ria.

### 4. Aprendizado por Refor√ßo
Introdu√ß√£o a modelos baseados em intera√ß√£o com o ambiente, abordando conceitos como **agentes**, **estados**, **a√ß√µes**, **recompensas** e pol√≠ticas de decis√£o.

### 5. Sistemas de Recomenda√ß√£o
Estudo de m√©todos para recomenda√ß√£o de itens, incluindo **filtragem colaborativa**, **baseada em popularidade** e abordagens h√≠bridas.

### 6. Machine Learning Avan√ßado
T√≥picos avan√ßados da √°rea que inclui temas como **gradiente descendente**, **valida√ß√£o cruzada**, **bootstrapping**, **curvas de aprendizagem** e estudos de caso.

### 7. Materiais complementares

---

<br>

## üéØ 1. Pr√©-requisitos: Processamento de Dados e M√©tricas de Avalia√ß√£o

Os materiais pr√°ticos se encontram nos arquivos:

    > 1.como manipular_dataframes.ipynb
    > 2.preparacao_de_dados.ipynb
    > 3.avaliacao_de_modelos.ipynb

Antes de explorar algoritmos de Machine Learning, √© fundamental dominar etapas iniciais de prepara√ß√£o e an√°lise de dados, bem como compreender as principais m√©tricas de avalia√ß√£o. Esses conceitos s√£o essenciais para garantir que os modelos sejam treinados corretamente e que seus resultados possam ser interpretados de forma confi√°vel.

## 1.1 Processamento de Dados
√â  a fase em que os dados s√£o limpos, transformados e organizados para serem utilizados pelos modelos. Inclui atividades como:

* Tratamento de valores ausentes: remo√ß√£o ou imputa√ß√£o de dados faltantes.
* Detec√ß√£o e remo√ß√£o de outliers: identificar dados inconsistentes que podem distorcer o modelo.
* Normaliza√ß√£o e padroniza√ß√£o: ajustar escalas das vari√°veis num√©ricas para melhorar a performance de algoritmos sens√≠veis a magnitude.
* Codifica√ß√£o de vari√°veis categ√≥ricas: transformar categorias em representa√ß√µes num√©ricas (como One-Hot Encoding ou Label Encoding).

## 1.2 Manipula√ß√£o de DataFrames

O uso de estruturas como o pandas DataFrame √© central para organizar e explorar dados. Com DataFrames, √© poss√≠vel:

* Selecionar colunas e linhas espec√≠ficas.
* Filtrar e agrupar informa√ß√µes para an√°lise.
* Criar novas vari√°veis derivadas.
* Integrar diferentes fontes de dados de forma eficiente.

## 1.3 M√©tricas de Avalia√ß√£o

Para medir a efic√°cia de um modelo, utilizamos m√©tricas que variam conforme o tipo de problema:

* Classifica√ß√£o: acur√°cia, precis√£o, recall, F1-score, matriz de confus√£o.
* Regress√£o: erro m√©dio absoluto (MAE), erro quadr√°tico m√©dio (MSE), raiz do erro quadr√°tico m√©dio (RMSE), erro percentual absoluto m√©dio (MAPE).

Compreender e aplicar essas m√©tricas permite comparar modelos, ajustar hiperpar√¢metros e interpretar resultados de forma objetiva.

---

<br>

## üéØ 2. Aprendizado Supervisionado

Os materiais pr√°ticos se encontram nos arquivos:

    > 4.modelos_de_classificacao.ipynb
    > 5.modelos_de_regressao.ipynb
    > 6.tecnicas_otimizacao_e_fine_tuning.ipynb

O **Aprendizado Supervisionado** √© um dos principais paradigmas do Machine Learning e se baseia no uso de **dados rotulados**, ou seja, exemplos de entrada acompanhados de uma sa√≠da conhecida. A partir desses dados, os modelos aprendem padr√µes que permitem **generalizar** e fazer previs√µes sobre novos dados.

Esse tipo de aprendizado √© amplamente utilizado em aplica√ß√µes do mundo real, como detec√ß√£o de spam, diagn√≥stico m√©dico, previs√£o de pre√ßos, reconhecimento de imagens e an√°lise de risco.

De forma geral, os problemas de aprendizado supervisionado podem ser divididos em duas grandes categorias: *classifica√ß√£o* e *regress√£o*.

### üîπ Classifica√ß√£o
Re√∫ne estudos e implementa√ß√µes de algoritmos cujo objetivo √© **atribuir uma classe ou r√≥tulo discreto** √†s observa√ß√µes.  
Exemplos comuns incluem classifica√ß√£o bin√°ria e multiclasse, como:
- Detec√ß√£o de spam
- Classifica√ß√£o de sentimentos
- Diagn√≥stico de doen√ßas

### üîπ Regress√£o
Cont√©m estudos e c√≥digos voltados para problemas em que o objetivo √© **prever valores cont√≠nuos**.  
Esse tipo de abordagem √© muito utilizado em tarefas como:
- Previs√£o de pre√ßos
- Estimativa de demanda
- An√°lise de tend√™ncias

---

<br>

## üéØ 3. Aprendizado N√£o Supervisionado

Os materiais pr√°ticos se encontram nos arquivos:

    > 7. clusterizacao.ipynb
    > 8. reducao_de_dimencionalidade.ipynb
    > 9. PLN_modelagem_de_topicos.ipynb

O **Aprendizado n√£o supervisionado** √© um tipo de t√©cnica de Machine Learning onde o modelo n√£o recebe r√≥tulos ou respostas (ou seja, n√£o h√° vari√°vel alvo) durante o treinamento. Em vez disso, o objetivo √© encontrar padr√µes, estruturas ou rela√ß√µes subjacentes dentro dos dados, como agrupamentos, padr√µes ou redu√ß√µes de dimensionalidade.

### **Caracter√≠sticas:**
* Sem r√≥tulos: Ao contr√°rio da aprendizagem supervisionada, onde o modelo √© treinado com dados rotulados (com a resposta), na aprendizagem n√£o supervisionada, o modelo trabalha com dados n√£o rotulados.
* Objetivo: O principal objetivo √© explorar os dados para descobrir estrutura ou padr√µes, como agrupamentos ou rela√ß√µes que n√£o s√£o evidentes √† primeira vista.
* Descoberta de padr√µes: Ao inv√©s de prever um valor, como na supervis√£o, o modelo tenta encontrar semelhan√ßas ou padr√µes nos dados, seja agrupando dados ou reduzindo a dimensionalidade para facilitar a visualiza√ß√£o e a interpreta√ß√£o.

### **Principais tipos:**

### üîπ Clustering (Agrupamento):
T√©cnica onde os dados s√£o divididos em grupos (ou clusters) baseados em semelhan√ßas. Os pontos de dados dentro de um mesmo grupo s√£o mais semelhantes entre si do que com os pontos de outros grupos. O K-Means √© um exemplo cl√°ssico, no qual o algoritmo tenta dividir os dados em k clusters com base na similaridade entre eles. O agrupamento √© amplamente usado em √°reas como segmenta√ß√£o de clientes, onde √© poss√≠vel agrupar consumidores com comportamentos similares, ou em an√°lise gen√©tica, para identificar padr√µes em dados biol√≥gicos. Ele tamb√©m √© √∫til na organiza√ß√£o de grandes volumes de dados, categorizando informa√ß√µes de maneira eficiente.

### üîπ Redu√ß√£o de Dimensionalidade:
 Tem como objetivo reduzir o n√∫mero de vari√°veis ou features de um conjunto de dados, mantendo a maior parte da informa√ß√£o relevante. Um exemplo cl√°ssico √© o PCA (Principal Component Analysis), que transforma dados de alta dimensionalidade em um conjunto menor, mantendo a maior vari√¢ncia poss√≠vel. Isso √© extremamente √∫til em visualiza√ß√£o de dados complexos, permitindo representar dados em 2D ou 3D, ou em preprocessamento de dados, para tornar outros algoritmos de Machine Learning mais eficientes. 

### üîπ An√°lise de Associa√ß√£o:
 Busca encontrar rela√ß√µes ou padr√µes frequentes entre itens em grandes bases de dados. O Algoritmo Apriori √© um exemplo cl√°ssico utilizado, especialmente em problemas de cesta de compras, onde se analisa quais produtos s√£o frequentemente comprados juntos. Isso √© particularmente √∫til em recomenda√ß√£o de produtos em lojas online, sugerindo itens baseados em compras anteriores. 

### üîπ Modelos de Mistura Gaussiana (GMM):
 Assumem que os dados s√£o gerados por uma combina√ß√£o de distribui√ß√µes gaussianas (ou normais). O GMM √© mais flex√≠vel que o K-Means, pois permite que os clusters tenham formas el√≠pticas, ao inv√©s de apenas esf√©ricas. Ele √© frequentemente utilizado em segmenta√ß√£o de mercado para entender padr√µes de consumo, ou na detec√ß√£o de anomalias, identificando dados que fogem do comportamento normal. Al√©m disso, o GMM √© utilizado em processamento de voz e an√°lise de sinais, para modelar dados cont√≠nuos e complexos, como os encontrados em sinais sonoros ou imagens.

---

<br>

## üéØ 4. Aprendizado por Refor√ßo

Os materiais pr√°ticos se encontram nos arquivos:

    > 10. aprendizado_por_reforco.ipynb

O **Aprendizado por refor√ßo** √© um campo da intelig√™ncia artificial (IA) onde um agente aprende a tomar decis√µes interagindo com um ambiente com o objetivo de maximizar uma fun√ß√£o de recompensa ao longo do tempo - o agente aprende por tentativa e erro, recebendo feedback (recompensas ou penalidades) com base nas a√ß√µes que toma, e ajusta suas decis√µes futuras com base nesse feedback.

### **Principais tipos:**

### üîπ Valor-based:
O agente aprende o valor dos estados ou a√ß√µes, utilizando fun√ß√µes como Q-learning. O objetivo √© determinar quais a√ß√µes s√£o melhores com base em valores num√©ricos atribu√≠dos a cada estado ou a√ß√£o, o que permite derivar uma pol√≠tica. Essa abordagem √© simples e funciona bem em ambientes discretos, mas n√£o √© eficiente para ambientes complexos ou cont√≠nuos.

### üîπ Policy-based:

O agente aprende diretamente uma pol√≠tica, ou seja, uma fun√ß√£o que mapeia estados para a√ß√µes, ajustando-se para maximizar a recompensa. Algoritmos como Policy Gradient fazem isso atrav√©s da otimiza√ß√£o direta da pol√≠tica. Essa abordagem √© mais flex√≠vel e eficaz em ambientes cont√≠nuos ou estoc√°sticos, mas pode ser ineficiente e inst√°vel.

### üîπ Model-based:

O agente tenta aprender ou usar um modelo do ambiente para prever como o ambiente reage √†s suas a√ß√µes. O objetivo principal √© permitir que o agente planeje suas a√ß√µes com base em previs√µes sobre o futuro, em vez de aprender apenas atrav√©s de tentativas e erros.

---

<br>

## üéØ 5. Sistemas de Recomenda√ß√£o

Os materiais pr√°ticos se encontram na pasta *sistemas_de_recomenda√ß√£o*, que est√° dividida da seguinte forma:

    > comece_aqui.ipynb
    > popularidade
    > exploracao_explotacao
    > matrizes_esparsas
    > reducao_dimencionalidade
    > agrupamento_vizinhos
    > funcoes_de_utilidade
    > engenharia_de_features

Os c√≥digos desse tema seguem as boas pr√°ticas de c√≥digo, utilizando modulariza√ß√£o.

Sistemas de recomenda√ß√£o s√£o programas ou algoritmos projetados para sugerir produtos, servi√ßos ou informa√ß√µes relevantes para usu√°rios com base em seus interesses, comportamento ou perfil. Eles est√£o por tr√°s de muitas das experi√™ncias personalizadas que usamos diariamente.

### üîπ Conceitos importantes:

Em sistemas de recomenda√ß√£o, os dados s√£o frequentemente representados como uma matriz, onde cada linha √© um usu√°rio e cada coluna √© um item. As c√©lulas dessa matriz cont√™m as avalia√ß√µes dos usu√°rios para os itens. **A matriz √© chamada de 'esparsa'** quando a maioria das c√©lulas est√° vazia, ou seja, a maioria dos usu√°rios n√£o avaliou todos os itens.

Outro conceito importante √© o da **representa√ß√£o vetorial**, j√° que muitos dos m√©todos de recomenda√ß√£o (como filtragem colaborativa) dependem da representa√ß√£o vetorial dos usu√°rios e itens. Um vetor √© simplesmente uma lista de n√∫meros que representam as prefer√™ncias ou caracter√≠sticas de um item ou usu√°rio. Por exemplo, um filme pode ser representado por um vetor de tr√™s n√∫meros, correspondendo a caracter√≠sticas como 'a√ß√£o', 'com√©dia' e 'drama', com valores representando a intensidade com que o filme possui essas caracter√≠sticas.

### üîπ Recomenda√ß√£o por popularidade:

√â uma abordagem simples e direta que sugere itens com base em sua popularidade geral entre todos os usu√°rios. Em vez de analisar prefer√™ncias individuais, o sistema indica os produtos, filmes ou conte√∫dos mais acessados, comprados ou avaliados positivamente. Essa estrat√©gia √© eficiente para situa√ß√µes em que ainda n√£o h√° dados sobre o usu√°rio, mas sua principal limita√ß√£o √© a falta de personaliza√ß√£o, pois nem todos os usu√°rios se interessam pelos itens mais populares.

**Balanceamento:** Consiste em combinar diferentes objetivos ao gerar sugest√µes para o usu√°rio. Por exemplo, o sistema pode tentar equilibrar popularidade, novidade, diversidade de categorias ou relev√¢ncia para o perfil individual. Essa estrat√©gia evita que o usu√°rio veja sempre os mesmos itens ou apenas os mais populares, garantindo uma experi√™ncia mais rica e variada, capaz de atender a diferentes interesses e contextos.

**Explora√ß√£o vs Explota√ß√£o:** A estrat√©gia de explora√ß√£o-explota√ß√£o busca equilibrar a apresenta√ß√£o de itens que o usu√°rio provavelmente vai gostar (explota√ß√£o do conhecimento existente) com itens novos ou alternativos (explora√ß√£o). Esse equil√≠brio permite que o sistema aprenda sobre os interesses do usu√°rio enquanto ainda entrega recomenda√ß√µes seguras e relevantes. T√©cnicas como multi-armed bandits s√£o comumente usadas para implementar esse conceito, maximizando engajamento, satisfa√ß√£o e descoberta de novos itens ao mesmo tempo.

### üîπ Filtragem colaborativa:

√â uma t√©cnica amplamente utilizada em sistemas de recomenda√ß√£o para prever os interesses ou prefer√™ncias de um usu√°rio, com base nas intera√ß√µes de outros usu√°rios semelhantes. O conceito central por tr√°s da filtragem colaborativa √© a ideia de que se dois usu√°rios t√™m um hist√≥rico de intera√ß√µes semelhante, √© prov√°vel que eles gostem das mesmas coisas.
Existem dois tipos principais de filtragem colaborativa: baseada em usu√°rios (user-based) e baseada em itens (item-based).

Aten√ß√£o para o problema do *"cold start"*: Se um usu√°rio ou item √© novo no sistema e n√£o tem intera√ß√µes suficientes, o sistema ter√° dificuldades em gerar recomenda√ß√µes precisas. Isso √© conhecido como o problema do "in√≠cio frio" (cold start). Para contornar isso, t√©cnicas como o uso de dados demogr√°ficos do usu√°rio ou de caracter√≠sticas do item (filmes, produtos, etc.) s√£o utilizadas para gerar recomenda√ß√µes iniciais.

**Como Calcular a Similaridade?**

Para calcular a similaridade entre usu√°rios ou itens, alguns m√©todos comuns incluem:

* Dist√¢ncia de Cosseno: Mede o √¢ngulo entre dois vetores (representa√ß√µes num√©ricas de intera√ß√µes) e calcula a similaridade entre eles. Quanto menor o √¢ngulo, maior a similaridade.
* Correla√ß√£o de Pearson: Mede a rela√ß√£o linear entre duas vari√°veis. Pode ser usada para medir a similaridade entre dois usu√°rios com base nas classifica√ß√µes que deram aos mesmos itens.
* Coeficiente de Jaccard: Mede a similaridade entre conjuntos, considerando a raz√£o entre a interse√ß√£o e a uni√£o desses conjuntos. Usado, por exemplo, quando lidamos com intera√ß√µes bin√°rias (como "gostei" ou "n√£o gostei").

### üîπ Fun√ß√µes de utilidade:

Uma fun√ß√£o de utilidade √© uma maneira de medir o quanto algo agrada ou satisfaz um usu√°rio. No contexto de sistemas de recomenda√ß√£o, a utilidade √© usada para calcular o qu√£o bom √© recomendar um item, baseado no que o usu√°rio gosta. Quanto maior a utilidade de um item para um usu√°rio, mais prov√°vel ele ser√° recomendado. A utilidade de um item pode ser dada por: 

* **Utilidade Cobb-Douglas**: Um modelo cl√°ssico em economia para representar prefer√™ncias de consumo, no qual a utilidade de um consumidor depende de quantidades consumidas de diferentes bens, com uma forma funcional espec√≠fica. A utilidade Cobb-Douglas assume que o consumidor tem uma combina√ß√£o de bens onde o produto das quantidades consumidas, ponderado pelos par√¢metros (ou exposi√ß√µes), resulta na utilidade total.
* **Utilidade de Elasticidade de Substitui√ß√£o Constante (CES)**: Outro tipo de utilidade usado em economia para modelar prefer√™ncias, onde a elasticidade de substitui√ß√£o entre bens √© constante. Nesse modelo, os bens podem ser substitu√≠dos entre si a uma taxa constante determinada pela elasticidade

O sistema tenta maximizar a utilidade da recomenda√ß√£o para o usu√°rio, sugerindo itens que ele provavelmente gostar√° mais.

---
<br>

# üìò 6. Machine Learning Avan√ßado

Os materiais pr√°ticos se encontram nos arquivos:

    > 11. gradiente_descendente.ipynb
    > 12. validacao_cruzada_e_bootstrapping.ipynb
    > 13. curva_de_aprendizagem_e_overfitting.ipynb

* O **gradiente descendente** √© apresentado como um dos principais algoritmos de otimiza√ß√£o, utilizado para minimizar a fun√ß√£o de erro e encontrar os melhores par√¢metros do modelo.

* T√©cnicas de avalia√ß√£o como **valida√ß√£o cruzada e bootstrapping** permitem estimar de forma mais confi√°vel o desempenho do modelo em dados n√£o vistos.

* A **curva de aprendizagem** √© utilizada para analisar o comportamento do modelo √† medida que aumenta a quantidade de dados de treino, ajudando a identificar problemas como overfitting e underfitting e a compreender se o modelo est√° generalizando adequadamente.

---
<br>

# üìò 7. Materiais complementares
* https://developers.google.com/machine-learning/glossary?hl=pt-br
* https://medium.com/@rajuhegde2006/aws-sage-maker-cdca68ca7c9b
* https://www.databricks.com/sites/default/files/2023-03/big-book-of-data-science-2ndedition.pdf
* https://datatron.com/what-is-a-machine-learning-pipeline/


